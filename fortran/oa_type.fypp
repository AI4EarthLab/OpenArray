
#:mute 
#:set TYPE_EXCEPT_NODE = [['int', 'integer'], &
       ['real',  'real'], &
       ['real8', 'real(kind=8)'], &
       ['array', 'type(array)']]
#:endmute       
module oa_type
  use instrict :: iso_c_binding
  type Array
     C_PTR :: ptr = C_NULL_PTR
   contains
     final :: destroy_array
  end type Array

  type Node
     C_PTR :: ptr = C_NULL_PTR
   contains
     final :: destroy_node
  end type Node

  interface create_node
#:for t in TYPE_EXCEPT_NODE
     module procedure create_node_${t[0]}$
#:endfor
     module procedure create_node_op1
     module procedure create_node_op2     
  end interface create_node
  
contains

  subroutine destroy_array(A)
    type(Array), intent(inout) :: A

    !call c function to destroy array here.
    
    A%ptr = C_NULL_PTR
  end subroutine

  subroutine destroy_node(A)
    type(Node), intent(inout) :: A

    !call c function to destroy node here.
    
    A%ptr = C_NULL_PTR
  end subroutine

#:for t in TYPE_EXCEPT_NODE
  subroutine create_node_${t[0]}$(B, A)
    type(node), intent(out) :: B
    ${t[1]}$ :: A

    !call c function to create a node
    print*, "create node : ${t[1]}$"
  end subroutine
  
#:endfor

  subroutine create_node_op1(B, OP, A)
    type(node), intent(out) :: B
    type(node), intent(in)  :: A    
    integer :: OP

    !call c function to create a node
    print*, "create node : ", op
  end subroutine

  subroutine create_node_op2(C, OP, A, B)
    type(node), intent(out) :: B
    type(node) :: A, B    
    integer :: OP

    !call c function to create a node
    print*, "create node : ", op    
  end subroutine
  
  
end module
