#:mute
#:include "../NodeType.fypp"
#:set types = [['real8','real(8)', 'scalar'],&
       ['real','real', 'scalar'], &
       ['integer','integer', 'scalar'], &
       ['array', 'type(array)', 'array'], &
       ['node', 'type(node)',  'node']]
#:endmute
       
module operators
  use instrict :: iso_c_binding
  use oa_type

#:for op in [o for o in L if o[3] == 'A' or o[3] == 'B']
  interface operator (${op[2]}$)
#:for type1 in types
#:for type2 in types
#:if not (type1[2] == 'scalar' and type2[2] == 'scalar')
     module procedure ops_${type1[0]}$_${op[1]}$_${type2[0]}$
#:endif
#:endfor
#:endfor
  end interface operator (${op[2]}$)
  
#:endfor
  
contains

#:for e in [x for x in L if x[3] == 'A' or x[3] == 'B']
#:set op = e[1]
#:for type1 in types
#:for type2 in types
#:if not (type1[2] == 'scalar' and type2[2] == 'scalar')
  function ops_${type1[0]}$_${op}$_${type2[0]}$(A, B) result(res)
    implicit none       
    ${type1[1]}$, intent(in) :: A
    ${type2[1]}$, intent(in) :: B
#:if type1[0] != 'node'
    type(node) :: C
#:endif
#:if type2[0] != 'node'
    type(node) :: D
#:endif
    type(node) :: res

#:if type1[0] == 'node'
#:set AC = 'A'
#:else
    call create_node(C, A)    
#:set AC = 'C'
#:endif

#:if type2[0] == 'node'
#:set BD = 'B'
#:else
    call create_node(D, B)
#:set BD = 'D'
#:endif

    call create_node(res, ${e[0]}$, ${AC}$, ${BD}$)

  end function

#:endif
#:endfor
#:endfor
#:endfor


#:for e in [x for x in L if x[3] == 'C']
#:set op = e[1]
#:for type1 in types
#:if not (type1[2] == 'scalar')
  function ops_${op}$(A) result(res)
    implicit none       
    ${type1[1]}$, intent(in) :: A
#:if type1[0] != 'node'
    type(node) :: C
#:endif

#:if type1[0] == 'node'
#:set AC = 'A'
#:else
    call create_node(C, A)
#:set AC = 'C'
#:endif

    call create_node(res, ${e[0]}$, ${AC}$)

  end function

#:endif
#:endfor
#:endfor
  
end module
